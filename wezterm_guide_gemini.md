Orchestrating Autonomous AI Developer Fleets: A Comprehensive Guide to WezTerm Automation via Lua1. Executive Summary: The Terminal as a Hypervisor for Synthetic IntelligenceThe evolution of the terminal emulator has traditionally followed the trajectory of human utility. From the teletypes of the 1970s to the GPU-accelerated renderers of the modern era, the design philosophy has centered on the human eye’s refresh rate, the human hand’s typing speed, and the cognitive bandwidth of a biological operator. However, a fundamental paradigm shift is currently reshaping the landscape of software engineering infrastructure. The emergence of autonomous AI coding agents—synthetic developers capable of navigating file systems, executing builds, analyzing error logs, and refactoring codebases—demands a reimagining of the terminal not as a display surface, but as a high-throughput execution hypervisor for silicon intelligence.This report serves as a definitive technical blueprint for infrastructure architects and DevOps engineers tasked with deploying and managing large-scale fleets of AI agents (such as Claude Code, Codex CLI, and Gemini-CLI). While these agents often provide their own CLI interfaces, managing them at scale—across distributed remote domains, with robust error recovery, resource isolation, and centralized telemetry—requires a control plane that is far more sophisticated than a simple shell script loop. WezTerm, a GPU-accelerated terminal emulator and multiplexer implemented in Rust with a deeply integrated Lua configuration engine, stands uniquely positioned to fill this role. Unlike traditional emulators that treat configuration as a static set of preferences, WezTerm exposes a programmable, event-driven runtime that allows for the precise orchestration of process lifecycles, the interception of inter-process communication (IPC), and the virtualization of remote environments.In the following sections, we will rigorously examine the architectural patterns necessary to transform WezTerm from a desktop tool into a headless automation server. We will explore the depths of the Lua API 1, dissecting the nuances of its multiplexer protocol 2, asynchronous process management 3, and the critical safety mechanisms required to prevent "rogue" agents from destabilizing host systems. By leveraging WezTerm’s ability to act as a persistent multiplexer server 2, we can decouple the lifecycle of the agent from the viewing client, ensuring that long-running refactoring tasks persist through network interruptions and client restarts. Furthermore, we will analyze performance optimization strategies 4 to ensure that the overhead of the terminal emulator does not cannibalize the compute resources required by the agents themselves.2. The WezTerm Multiplexer Architecture: A Distributed State MachineTo automate WezTerm effectively for a fleet of AI agents, one must first discard the mental model of a terminal as a window on a desktop. In the context of high-reliability automation, WezTerm operates as a distributed client-server application where the "server" (the multiplexer or mux) maintains the authoritative state of all terminal sessions, windows, tabs, and scrollback history, while the "client" (the GUI or CLI) acts merely as a transient interface to that state.5 This architectural separation is the cornerstone of reliability for autonomous workflows, as it allows the execution environment to be completely decoupled from the rendering environment.2.1 The Mux Server-Client ModelThe WezTerm multiplexer creates a persistent runtime environment that survives graphical interface restarts, network interruptions, or crash-loops of the rendering frontend.2 For an AI fleet, this means an agent can be spawned on a remote server via an SSH domain 2, and the controlling logic (running on the local Lua engine or a dedicated management node) can detach and reattach at will without terminating the agent's process. The communication between the client and the server occurs over a defined protocol that can run over Unix domain sockets for local persistence, or secure TCP/TLS channels for remote control.2When a Lua command such as mux.spawn_window is executed 6, it effectively dispatches a Remote Procedure Call (RPC) to the mux server, instructing it to alter its internal state tree. This distinction is vital for performance and reliability; in high-density deployments, the recommended best practice is to run the wezterm-mux-server as a systemd daemon on headless infrastructure (the "remote domains").7 This configuration offloads the heavy lifting of Pseudo-Terminal (PTY) management, output buffering, and process supervision to a dedicated daemon, leaving the client free to handle high-level orchestration logic without being bogged down by the immediate I/O interrupt load of hundreds of active terminals.It is critical to note that the WezTerm configuration file (wezterm.lua) can be evaluated in multiple contexts—both in the GUI client and the mux server.7 Understanding which process is evaluating the config is essential for avoiding "split-brain" scenarios where the client expects one state but the server enforces another. Automation scripts must be written to be context-aware, checking wezterm.mux.get_domain() to determine if they are operating on local or remote entities.2.2 Domain Isolation and Fault ToleranceWezTerm organizes panes into Domains, which serve as the primary boundaries for process isolation and fault tolerance.2 For a fleet of coding agents, utilizing distinct domains is a mandatory strategy to prevent cascading failures.Local Domain: The default domain where processes run as children of the WezTerm process on the local machine. While easiest to configure, it poses a significant risk for automation: if the local WezTerm instance crashes or is terminated by the OS (e.g., due to an out-of-memory event caused by a memory-leaking agent), all local agents are immediately killed.Unix Domain: This domain type creates a separate wezterm-mux-server process managed via a Unix socket.2 If the GUI client crashes, the server—and by extension, the agents—persist. This is the minimum recommended configuration for any automated workflow. By connecting to a local Unix domain, you effectively "remote" into your own machine, decoupling the volatile GUI lifecycle from the mission-critical agent lifecycle.SSH Domain: This encapsulates the state on a remote machine.2 The Lua configuration on the local machine acts as a controller, but the PTYs are allocated on the remote host. This is the ideal architecture for managing agents running in cloud environments (e.g., AWS EC2, GCP) or within distinct containerized environments. It leverages the robustness of the SSH protocol for transport security and authentication.TLS Domain: Similar to SSH but uses WezTerm’s custom TLS protocol.2 This domain type can offer lower latency than SSH for multiplexing heavy text throughput, a critical factor when monitoring fifty concurrent agents streaming verbose build logs or debug data. It avoids the overhead of the SSH channel windowing mechanism, which can become a bottleneck at scale.By assigning different agent clusters to different domains (e.g., Domain_Frontend_Refactor, Domain_Backend_Migration), you create explicit failure boundaries. A segfault in the PTY handling or a resource exhaustion event in one domain will generally not destabilize the others, ensuring the resilience of the overall fleet.2.3 Protocol Nuances and VersioningThe communication between the WezTerm client and the mux server relies on a structured protocol, often involving Protocol Buffers (protobuf) and LEB128 encoding for efficiency.10 A critical operational risk in distributed fleets is version drift. If the local client and the remote mux server are running different versions of WezTerm, the protocol handshake may fail, typically manifesting as "EOF while reading leb128 encoded value" errors.10For a robust fleet, it is imperative to implement a strict version management strategy. The automation pipeline should ensure that the wezterm-mux-server binary on all remote nodes is synchronized with the controller's version. While WezTerm generally strives for backward compatibility, the rapid pace of development in the nightly builds means that protocol breaking changes can occur. Automated deployment scripts (using Ansible or similar tools) should lock the WezTerm version across the fleet to a specific commit hash or release tag to prevent protocol mismatches from severing control connections.3. The Lua Control Plane: Configuration as CodeThe extensive integration of Lua 5.4 transforms the wezterm.lua configuration file from a static list of settings into a dynamic, Turing-complete control plane.1 This file is evaluated upon startup and every time the configuration is reloaded.13 Crucially, the Lua state persists for the lifetime of the process in specific contexts, such as event handlers, allowing for the implementation of complex, stateful automation logic that can track the progress of agents over time.3.1 The wezterm Module and API SurfaceThe wezterm module exposes the internal API surface required for automation.1 While typical users focus on cosmetic settings like config.font_size, automation engineers must master the operational sub-modules:wezterm.mux: Provides direct programmatic access to the multiplexer object model, allowing for the creation, manipulation, and destruction of Windows, Tabs, and Panes.6wezterm.procinfo: Allows for introspection of the process tree running inside panes.14 This is essential for health checks, such as verifying if codex-cli is still running or has exited unexpectedly.wezterm.time: Essential for scheduling non-blocking checks, delays, and timeouts, preventing the automation logic from freezing the terminal interface.wezterm.action: Defines the "verbs" of the system, such as SpawnCommandInNewTab, SplitPane, and SendText, which are used to drive the agents.33.2 Asynchronous Execution and Event LoopsA critical limitation to understand is that the main body of wezterm.lua is executed synchronously during startup and configuration reload. Placing heavy automation logic, such as polling a remote API or performing blocking I/O, in the top-level scope will freeze the terminal initialization and render the application unresponsive.15Robust automation must instead rely on Event Handlers.16 WezTerm emits a variety of events, including update-status 18, window-config-reloaded 13, and user-var-changed.19 Your automation logic should be defined as callback functions registered to these events. This effectively transforms WezTerm into an event loop:Trigger: An event occurs, such as an agent finishing a task (signaled via a User Var change) or a periodic timer expiring (via the Status Update loop).Reaction: The Lua callback is invoked to analyze the current state, perhaps by inspecting pane content via pane:get_text 20 or checking user variables.21Action: The callback executes a state change, such as spawning a new tab for the next task or sending a command to an idle agent.This event-driven model allows WezTerm to manage hundreds of agents responsively. The update-status event, for example, fires periodically (typically every second), providing a regular "tick" for the automation engine to perform housekeeping tasks, check for timeouts, and update the display with fleet metrics.3.3 Dynamic Configuration LoadingFor a large fleet, a single monolithic wezterm.lua file quickly becomes unmanageable and difficult to debug. Lua’s require function allows you to modularize your agent logic into separate files.22 You might organize your configuration with distinct modules like agents/codex.lua and agents/claude.lua, each exporting a table of lifecycle functions (e.g., spawn, monitor, kill).A recommended pattern is to have a bootstrap.lua entry point that detects the execution environment and loads the appropriate modules dynamically. For example, if the hostname indicates the machine is a GPU cluster node, the script could load the heavy-duty agent configurations; if it detects a laptop environment, it might instead load a lightweight monitoring dashboard. This ensures that the configuration remains flexible and scalable across heterogeneous infrastructure.224. Pane Lifecycle Management: The Agent ContainerIn the WezTerm ecosystem, the Pane is the fundamental unit of execution. For an AI agent, the Pane acts as its container—it holds the shell environment, the running process (e.g., the Python interpreter for the agent), and the complete history of its standard output and error streams. Automating the lifecycle of these panes—creation, monitoring, and termination—is the primary task of the fleet manager.4.1 Spawning and Layout StrategyWhile human users typically arrange panes using SplitHorizontal or SplitVertical based on visual preference, automated management requires a topological and programmatic approach. You should utilize the mux.spawn_window API 6 to create dedicated workspaces or windows for different classes of tasks.When spawning an agent, precise control over its initial environment is mandatory to ensure reproducibility. The SpawnCommand table allows you to specify:cwd: The current working directory, which should be set to the repository or project folder the agent is tasked with refactoring.23args: The exact command line arguments to launch the agent (e.g., {'codex', 'run', '--task', 'fix_login_bug'}).domain: The target execution environment, ensuring the agent runs on the correct local or remote infrastructure.set_environment_variables: This allows for the injection of API keys, unique agent IDs, and configuration flags directly into the process environment without polluting the global scope or relying on the shell's state.24Insight: Avoid relying on the default shell (e.g., just spawning bash). Instead, explicitly spawn the agent binary (e.g., /usr/local/bin/codex-cli) as the top-level process in the pane whenever possible. This simplifies process monitoring; if the pane closes, you know the agent process has terminated, rather than just a shell exiting or crashing.4.2 Addressing and ID ManagementEvery pane in WezTerm is assigned a unique integer pane_id.25 This ID is the handle by which your Lua script and external tools will reference the agent throughout its lifecycle. When you spawn a window or split a pane via the mux API, the returned object contains this ID.Best Practice: Maintain a state table in your Lua script (e.g., ActiveAgents = {}) that maps pane_id to agent metadata (e.g., Task ID, Start Time, Expected Duration). This state table allows your update-status loop to perform garbage collection—identifying and killing panes that have exceeded their timeout or flagging "zombie" agents that have stopped emitting heartbeats. Without this tracking, long-running deployments can suffer from resource leaks as "orphan" panes accumulate.4.3 Headless Operations and DaemonizationFor a fleet running on servers, relying on a graphical desktop environment is often impossible or inefficient. WezTerm supports a headless mode, but its implementation is nuanced.5 The wezterm-gui process is typically responsible for the windowing logic, but in a headless context, the wezterm-mux-server takes center stage.To run a true headless fleet, you should launch the wezterm-mux-server with the --daemonize flag.7 This allows the server to run in the background, detached from any controlling terminal. You can then connect to it using wezterm cli or a local Lua script connecting via a Unix domain socket. It is critical to ensure that your Lua configuration checks for the presence of the GUI (if wezterm.gui then...) before calling GUI-specific functions like window:set_title.15 Calling these functions in a headless server context where no GUI window exists can lead to runtime errors that may crash the mux server.5. The Input/Output Pipeline: Reading and WritingThe core of the interaction with an AI agent involves reading its textual output—which includes its reasoning traces, code generation, and prompts—and sending it commands, such as confirmations or new task descriptions. WezTerm provides multiple mechanisms for these I/O operations, but they possess vastly different performance characteristics that can make or break a large-scale deployment.5.1 Reading Pane Content: The Performance TrapThe naive approach to reading agent output is to use the pane:get_text() or pane:get_lines_as_text() functions inside a polling loop (e.g., within the update-status event handler running every second).16 This is strongly discouraged for large fleets.These functions require WezTerm to lock the pane, serialize the terminal grid (which might contain thousands of lines of scrollback with complex formatting), and pass it to the Lua engine as a string.26 Doing this for 50 agents every second will saturate the CPU, cause the mux server to stutter, and degrade the performance of the agents themselves.Optimized Strategy:Event-Driven Reads: Only call get_text() when you receive a specific signal that something significant has changed. This is best implemented using the "User Var" signaling protocol discussed in Chapter 6.Range-Limited Reads: Use the optional arguments to get_lines_as_text to read only the viewport or the last N lines. Avoid fetching the entire scrollback unless you are performing a specific post-mortem analysis after a failure.CLI vs. Lua: The wezterm cli get-text command spawns a new process for each invocation.20 In a tight loop, the process creation overhead is prohibitive. Always prefer the internal Lua API (pane:get_text) over the CLI wrapper when running code inside the WezTerm process.5.2 Sending Input and Handling Interactive PromptsSending text to an agent is generally safer and less resource-intensive. The standard method is pane:send_text("response\n").27 However, AI agents often use sophisticated TUI (Text User Interface) libraries (like ink in JavaScript or ratatui in Rust) that may interpret input differently depending on the terminal's "bracketed paste" mode.Safety Tip: Use pane:send_text with the --no-paste option (or equivalent Lua config) for sending control codes like Ctrl+C or Ctrl+D.27 For sending large code blocks or complex prompts to the agent, use bracketed paste mode (often the default) to ensure the text is treated as a single block of input. This prevents the shell from interpreting line breaks within the code as execution commands before the transmission is complete.For interactive agents like Claude Code or Codex CLI, which might pause and ask "Do you want to run this command? (y/n)", your automation must reliably detect this prompt. Since you cannot easily rely on visual cursor position in Lua, you must rely on the output stream. This reinforces the need for the User Var Signaling Protocol discussed in the next section, as heuristic parsing of "y/n" prompts on stdout is notoriously brittle—vulnerable to changes in color codes, formatting, and partial writes.5.3 Logging and Audit Trails: wezterm recordFor compliance, debugging, and dataset creation, relying solely on ephemeral pane text is insufficient. WezTerm’s record feature captures the raw byte stream of a session into an asciicast v2 file (a newline-delimited JSON format).28Implementation:When spawning an agent, wrap the command as follows:wezterm record --output /logs/agent_123.cast -- /usr/local/bin/codex-cli...This recording happens at the PTY level in Rust and has effectively zero overhead on the Lua engine.26 The resulting files are compact, compressed text logs that preserve all timing information and escape sequences. They can be replayed later using wezterm replay or standard tools like asciinema.30 This is invaluable for post-hoc analysis—understanding why an agent failed or verifying that it didn't hallucinate destructive commands—without the performance penalty of real-time logging in Lua.6. Event-Driven Architecture: The User Var Signaling ProtocolThis is the most critical architectural pattern for high-performance automation. It shifts the paradigm from the Lua script constantly polling the agent ("Are you done? Are you done?") to the agent signaling the Lua script ("I am waiting for input", "I have failed", "I am finished").WezTerm supports a specific ANSI escape sequence: OSC 1337 ; SetUserVar = <key> = <base64_value> ST.21 This allows any program running inside the terminal to set a variable attached to the pane.6.1 The Protocol DesignWe establish a protocol where the AI agent (or a wrapper script around it) emits these sequences to communicate state changes.The Wrapper Script (Bash/Python/Rust):Bash#!/bin/bash
# Wrapper for the AI Agent
function emit_state() {
  # Base64 encode the value to ensure safe transmission
  local val=$(echo -n "$1" | base64)
  printf "\033]1337;SetUserVar=AgentState=%s\007" "$val"
}

emit_state "Initializing"
/usr/bin/ai-agent --task "$1"
EXIT_CODE=$?

if; then
  emit_state "Success"
else
  emit_state "Failed"
fi
6.2 The Lua ListenerIn wezterm.lua, we subscribe to the user-var-changed event.19 This event fires immediately when the escape sequence is parsed by the terminal emulator, providing near-instantaneous reaction times.Luawezterm.on('user-var-changed', function(window, pane, name, value)
  if name == "AgentState" then
    local state = value
    local id = pane:pane_id()
    
    if state == "Success" then
      wezterm.log_info("Agent ".. id.. " finished successfully.")
      -- Trigger next workflow step or kill pane
      window:perform_action(wezterm.action.CloseCurrentPane { confirm = false }, pane)
    elseif state == "Waiting" then
      -- Agent needs help. Now we justify the cost of reading the screen.
      local text = pane:get_lines_as_text(20) -- Read last 20 lines
      local response = AnalyzePrompt(text) -- Hypothetical logic function
      pane:send_text(response.. "\n")
    end
  end
end)
Third-Order Insight: This inversion of control solves the "Context Window Full" problem elegantly. If an agent detects its context is full (e.g., Claude Code's compaction warning 31), it can emit a specific signal like SetUserVar=ContextStatus=Critical. The Lua script can catch this signal and automatically trigger a wezterm.action.SendString("/compact\n") command to the pane.32 This automates the maintenance of the agent's cognitive buffer without human intervention and without the Lua script needing to constantly parse the text stream for warning messages.6.3 Signal Propagation in Remote DomainsA crucial aspect of this protocol is its behavior across remote connections. WezTerm is designed to propagate user variables from a remote multiplexer pane (e.g., in an SSH domain) back to the client.21 This means that an agent running on a cloud server can emit an OSC 1337 sequence, and the Lua script running on your local machine (or a central management server) will receive the user-var-changed event.However, there are nuances to this propagation. In some versions, user variables might not be synchronized immediately upon re-attaching to a session if they were set while the client was detached.33 To mitigate this, your agent wrapper script should implement a "state rebroadcast" mechanism, where it periodically re-emits the current state or emits it upon receiving a specific query signal (e.g., a SIGUSR1) from the controller.7. Performance Optimization for ScaleRunning a "fleet" implies concurrency. If you run 50 GPU-accelerated terminal instances, each rendering at 60 FPS, you will exhaust system resources quickly. Optimizing WezTerm for headless, high-density operation is mandatory to ensure that the CPU cycles are spent on the agents' logic (e.g., compilation, inference), not on drawing invisible pixels.7.1 The WebGpu vs. Software RendererBy default, WezTerm attempts to use the GPU for rendering. For a headless server managing agents, this is often unnecessary overhead or impossible if no GPU exists.Recommendation: Force the front_end configuration to "Software".Config: config.front_end = "Software" 4This moves the rendering pipeline to the CPU (typically using llvmpipe on Linux). While "software rendering" sounds slower, for a multiplexer server that is rarely viewed by a human, it is perfectly adequate and avoids the complexities of initializing a GPU context in a headless environment.7.2 Frame Rate ThrottlingWezTerm defaults to 60 FPS.35 For an automated fleet, updating the internal framebuffer 60 times a second is a waste of cycles.Config: config.max_fps = 10 (or even lower, e.g., 5).Config: config.animation_fps = 1.This drastically reduces the CPU usage of the wezterm-mux-server process. By setting animation_fps to 1, you also disable expensive calculations for smooth cursor blinking, which are irrelevant for automation.347.3 Scrollback LimitationInfinite scrollback is a dangerous memory leak in a long-running process. An AI agent might output megabytes of text during a compile loop or a verbose debugging session.Config: config.scrollback_lines = 10000 (or a similarly safe upper bound).If you rely on wezterm record for persistent logs (as recommended in Section 5.3), you do not need the scrollback buffer to hold the entire history in RAM. This protects the mux server from Out-Of-Memory (OOM) kills, ensuring the stability of the entire fleet.8. Integration with External Systems: Rust and Named PipesWhile Lua is powerful, it is single-threaded and runs inside the WezTerm process. For heavy-duty logic—such as calling an OpenAI API to analyze an error log, updating a SQL database with agent status, or performing complex text processing—you should offload the work to an external process.8.1 Non-Blocking I/O via Named PipesA robust pattern for Inter-Process Communication (IPC) is to utilize Named Pipes (FIFOs) on the filesystem. The Lua script can write JSON payloads to this pipe using standard Lua I/O. However, standard file opening in Lua can block if the reader is not ready, which would freeze WezTerm.36To implement non-blocking I/O in Lua without external C libraries (which are hard to integrate into the embedded Lua engine), you can use wezterm.background_child_process to act as the writer, or carefully manage the pipe's lifecycle. A dedicated external service (written in Rust or Python) should act as the "Fleet Commander." It reads the stream of events from the pipe, performs the heavy API calls, and then issues commands back to WezTerm via the wezterm cli or by writing to a separate control pipe that the Lua script monitors.8.2 The background_child_process Escape HatchIf you need to fire-and-forget a command (e.g., "Notify Slack that Agent 9 failed"), use wezterm.background_child_process.3 This spawns a detached process that does not block the Lua event loop.Critical Warning: Do not use os.execute or io.popen in the main Lua thread for anything that involves network I/O or potentially long-running operations. These standard Lua functions are synchronous and will freeze the entire multiplexer—and all other agents—until they return.159. Reliability and Safety MechanismsAutonomous agents are prone to "going rogue"—deleting files, spawning infinite loops, or hanging indefinitely. WezTerm provides safety rails that can be configured to contain these risks.9.1 Interactive Confirmations and "Y/N" TrapsEven automated agents sometimes hit interactive prompts (e.g., rm -rf * asking for confirmation). WezTerm’s skip_close_confirmation_for_processes_named allows you to define which processes can be killed without a prompt, but for agents, you want strict control to avoid accidental data loss or hanging sessions.Strategy: Configure the agent's environment (via set_environment_variables) to be non-interactive. Common variables include DEBIAN_FRONTEND=noninteractive and CI=true. Most robust CLI tools respect these variables and suppress prompts, defaulting to a fail-safe or default behavior.9.2 Zombie Process CleanupUse the wezterm.procinfo module in a periodic update-status check to validate that the process ID (PID) associated with a pane is still alive.14 If the PID is gone but the pane remains open (because exit_behavior="Hold" is set for debugging purposes), the Lua script should log the exit code and close the pane to free resources.Lualocal info = pane:get_foreground_process_info()
if info and info.status == "Zombie" then
   wezterm.log_info("Reaping zombie pane ".. pane:pane_id())
   pane:process_action(wezterm.action.CloseCurrentPane{confirm=false})
end
10. Specific Agent Integration Strategies10.1 Claude CodeClaude Code (the CLI) features a "compaction" mechanism to manage its context window. It warns the user when the context is full.Integration: Use the user-var-changed protocol to detect this warning (via a wrapper script that greps the output or hooks into Claude's own events if available). Upon detection, automatically send the /compact command to the pane to trigger summarization and free up context tokens.3110.2 Codex CLICodex CLI often enforces rate limits or usage quotas.38Integration: Implement a rate-limiter in your Lua spawn logic. Use wezterm.time to track the last spawn time and enforce a delay (e.g., "Max 1 agent start per 5 seconds") to avoid hitting API rate limits during a fleet restart.11. ConclusionAutomating WezTerm for an AI fleet moves the terminal from a passive tool to an active participant in the software development lifecycle. By leveraging the Mux Server for persistence, the Lua API for event-driven logic, and the User Var protocol for low-latency signaling, one can build a system where hundreds of AI agents operate autonomously, safe from the fragility of screen scraping and the overhead of graphical rendering.This architecture treats the terminal pane as a micro-container—lightweight, observable, and ephemeral. The Lua configuration becomes the orchestrator, bridging the gap between the raw byte streams of the shell and the structured logic of the AI controller. As AI coding agents become more prevalent, this "Terminal-as-API" approach will likely become a standard pattern in DevOps infrastructure, with WezTerm currently standing as the most capable platform for its implementation.11.1 Future OutlookWe anticipate that future versions of WezTerm (and potentially competing emulators) will formalize "Agent Protocol" standards—native JSON output modes, structured event busses, and perhaps direct integration with LLM APIs—rendering some of the manual plumbing described here obsolete. Until then, the techniques detailed in this report represent the state of the art in terminal automation.