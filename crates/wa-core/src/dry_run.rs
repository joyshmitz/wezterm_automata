//! Dry-run preview infrastructure
//!
//! Provides the foundational infrastructure to thread dry_run mode through all
//! command execution paths. When dry_run is enabled, commands perform all
//! validation and resolution but don't execute side effects.

use std::fmt;

use serde::{Deserialize, Serialize};

use crate::policy::{PolicyDecision, Redactor};

// ============================================================================
// Core Types
// ============================================================================

/// Context for command execution that carries dry-run intent.
#[derive(Debug, Clone)]
pub struct CommandContext {
    /// Whether dry-run mode is enabled
    pub dry_run: bool,
    /// Command string for reporting
    pub command: String,
}

impl CommandContext {
    /// Create a new command context
    #[must_use]
    pub fn new(command: impl Into<String>, dry_run: bool) -> Self {
        Self {
            dry_run,
            command: command.into(),
        }
    }

    /// Check if this is a dry-run execution
    #[must_use]
    pub fn is_dry_run(&self) -> bool {
        self.dry_run
    }

    /// Build a dry-run context seeded with this command
    #[must_use]
    pub fn dry_run_context(&self) -> DryRunContext {
        let mut ctx = DryRunContext::from_flag(self.dry_run);
        ctx.set_command(self.command.clone());
        ctx
    }
}

/// Context for dry-run mode execution.
///
/// Carries the dry_run flag and collects information for the report.
#[derive(Debug, Clone, Default)]
pub struct DryRunContext {
    /// Whether dry-run mode is enabled
    pub enabled: bool,
    /// Report builder for collecting dry-run information
    pub report: DryRunReport,
}

impl DryRunContext {
    /// Create a new context with dry-run enabled
    #[must_use]
    pub fn enabled() -> Self {
        Self {
            enabled: true,
            report: DryRunReport::default(),
        }
    }

    /// Create a new context with dry-run disabled (normal execution)
    #[must_use]
    pub fn disabled() -> Self {
        Self {
            enabled: false,
            report: DryRunReport::default(),
        }
    }

    /// Create a context from a flag value
    #[must_use]
    pub fn from_flag(dry_run: bool) -> Self {
        if dry_run {
            Self::enabled()
        } else {
            Self::disabled()
        }
    }

    /// Check if this is a dry-run execution
    #[must_use]
    pub fn is_dry_run(&self) -> bool {
        self.enabled
    }

    /// Add a warning to the report
    pub fn add_warning(&mut self, warning: impl Into<String>) {
        self.report.warnings.push(warning.into());
    }

    /// Set the command being executed
    pub fn set_command(&mut self, command: impl Into<String>) {
        self.report.command = command.into();
    }

    /// Set target resolution information
    pub fn set_target(&mut self, target: TargetResolution) {
        self.report.target_resolution = Some(target);
    }

    /// Set policy evaluation result
    pub fn set_policy_evaluation(&mut self, evaluation: PolicyEvaluation) {
        self.report.policy_evaluation = Some(evaluation);
    }

    /// Add a planned action
    pub fn add_action(&mut self, action: PlannedAction) {
        self.report.expected_actions.push(action);
    }

    /// Take the report, consuming the context
    #[must_use]
    pub fn take_report(self) -> DryRunReport {
        self.report
    }
}

/// Report generated by a dry-run execution.
///
/// Contains all the information about what would happen if the command
/// were executed for real.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DryRunReport {
    /// The command being executed
    pub command: String,

    /// Target resolution information (pane, domain, etc.)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_resolution: Option<TargetResolution>,

    /// Policy evaluation results
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_evaluation: Option<PolicyEvaluation>,

    /// Expected actions that would be performed
    pub expected_actions: Vec<PlannedAction>,

    /// Warnings encountered during dry-run
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub warnings: Vec<String>,
}

impl DryRunReport {
    /// Create a new empty report
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a report with a command
    #[must_use]
    pub fn with_command(command: impl Into<String>) -> Self {
        Self {
            command: command.into(),
            ..Default::default()
        }
    }

    /// Check if there are any warnings
    #[must_use]
    pub fn has_warnings(&self) -> bool {
        !self.warnings.is_empty()
    }

    /// Check if all policy checks passed
    #[must_use]
    pub fn policy_passed(&self) -> bool {
        self.policy_evaluation
            .as_ref()
            .is_none_or(PolicyEvaluation::all_passed)
    }

    /// Get the number of planned actions
    #[must_use]
    pub fn action_count(&self) -> usize {
        self.expected_actions.len()
    }

    /// Return a redacted copy of this report for safe output.
    #[must_use]
    pub fn redacted(&self) -> Self {
        let redactor = Redactor::new();
        let mut report = self.clone();

        report.command = redactor.redact(&report.command);

        if let Some(target) = &mut report.target_resolution {
            target.domain = redactor.redact(&target.domain);
            if let Some(title) = &mut target.title {
                *title = redactor.redact(title);
            }
            if let Some(cwd) = &mut target.cwd {
                *cwd = redactor.redact(cwd);
            }
            if let Some(agent) = &mut target.agent_type {
                *agent = redactor.redact(agent);
            }
        }

        if let Some(policy) = &mut report.policy_evaluation {
            for check in &mut policy.checks {
                check.name = redactor.redact(&check.name);
                check.message = redactor.redact(&check.message);
                if let Some(details) = &mut check.details {
                    *details = redactor.redact(details);
                }
            }
        }

        for action in &mut report.expected_actions {
            action.description = redactor.redact(&action.description);
            if let Some(metadata) = &mut action.metadata {
                redact_json_value(metadata, &redactor);
            }
        }

        for warning in &mut report.warnings {
            *warning = redactor.redact(warning);
        }

        report
    }
}

// ============================================================================
// Target Resolution
// ============================================================================

/// Information about the resolved target for a command.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetResolution {
    /// Target pane ID
    pub pane_id: u64,

    /// Pane title (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    /// Current working directory
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cwd: Option<String>,

    /// Domain (local, ssh:host, etc.)
    pub domain: String,

    /// Whether the pane is currently active
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_active: Option<bool>,

    /// Detected agent type running in pane
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_type: Option<String>,
}

impl TargetResolution {
    /// Create a new target resolution
    #[must_use]
    pub fn new(pane_id: u64, domain: impl Into<String>) -> Self {
        Self {
            pane_id,
            title: None,
            cwd: None,
            domain: domain.into(),
            is_active: None,
            agent_type: None,
        }
    }

    /// Set the pane title
    #[must_use]
    pub fn with_title(mut self, title: impl Into<String>) -> Self {
        self.title = Some(title.into());
        self
    }

    /// Set the current working directory
    #[must_use]
    pub fn with_cwd(mut self, cwd: impl Into<String>) -> Self {
        self.cwd = Some(cwd.into());
        self
    }

    /// Set whether the pane is active
    #[must_use]
    pub fn with_is_active(mut self, is_active: bool) -> Self {
        self.is_active = Some(is_active);
        self
    }

    /// Set the detected agent type
    #[must_use]
    pub fn with_agent_type(mut self, agent_type: impl Into<String>) -> Self {
        self.agent_type = Some(agent_type.into());
        self
    }
}

// ============================================================================
// Policy Evaluation
// ============================================================================

/// Results of policy checks for a command.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyEvaluation {
    /// Individual check results
    pub checks: Vec<PolicyCheck>,
}

impl PolicyEvaluation {
    /// Create a new policy evaluation
    #[must_use]
    pub fn new() -> Self {
        Self { checks: Vec::new() }
    }

    /// Add a policy check result
    pub fn add_check(&mut self, check: PolicyCheck) {
        self.checks.push(check);
    }

    /// Check if all policy checks passed
    #[must_use]
    pub fn all_passed(&self) -> bool {
        self.checks.iter().all(|c| c.passed)
    }

    /// Get failed checks
    #[must_use]
    pub fn failed_checks(&self) -> Vec<&PolicyCheck> {
        self.checks.iter().filter(|c| !c.passed).collect()
    }
}

impl Default for PolicyEvaluation {
    fn default() -> Self {
        Self::new()
    }
}

/// A single policy check result.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyCheck {
    /// Name of the check
    pub name: String,

    /// Whether the check passed
    pub passed: bool,

    /// Human-readable status message
    pub message: String,

    /// Additional details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<String>,
}

impl PolicyCheck {
    /// Create a passing check
    #[must_use]
    pub fn passed(name: impl Into<String>, message: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            passed: true,
            message: message.into(),
            details: None,
        }
    }

    /// Create a failing check
    #[must_use]
    pub fn failed(name: impl Into<String>, message: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            passed: false,
            message: message.into(),
            details: None,
        }
    }

    /// Add details to the check
    #[must_use]
    pub fn with_details(mut self, details: impl Into<String>) -> Self {
        self.details = Some(details.into());
        self
    }
}

/// Convert a PolicyDecision to a PolicyCheck
impl From<&PolicyDecision> for PolicyCheck {
    fn from(decision: &PolicyDecision) -> Self {
        match decision {
            PolicyDecision::Allow { .. } => Self::passed("policy", "Operation allowed"),
            PolicyDecision::Deny { reason, .. } => Self::failed("policy", reason.as_str()),
            PolicyDecision::RequireApproval { reason, .. } => {
                Self::failed("policy", format!("Approval required: {reason}"))
            }
        }
    }
}

// ============================================================================
// Planned Actions
// ============================================================================

/// A planned action that would be performed during execution.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlannedAction {
    /// Step number in sequence
    pub step: u32,

    /// Action type
    pub action_type: ActionType,

    /// Human-readable description
    pub description: String,

    /// Additional metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
}

impl PlannedAction {
    /// Create a new planned action
    #[must_use]
    pub fn new(step: u32, action_type: ActionType, description: impl Into<String>) -> Self {
        Self {
            step,
            action_type,
            description: description.into(),
            metadata: None,
        }
    }

    /// Add metadata to the action
    #[must_use]
    pub fn with_metadata(mut self, metadata: serde_json::Value) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Types of actions that can be planned.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ActionType {
    /// Send text to a pane
    SendText,
    /// Wait for a condition
    WaitFor,
    /// Acquire a lock
    AcquireLock,
    /// Release a lock
    ReleaseLock,
    /// Store data in database
    StoreData,
    /// Execute a workflow step
    WorkflowStep,
    /// Mark an event as handled
    MarkEventHandled,
    /// Validate approval token
    ValidateApproval,
    /// Other/custom action
    Other,
}

impl fmt::Display for ActionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::SendText => write!(f, "send-text"),
            Self::WaitFor => write!(f, "wait-for"),
            Self::AcquireLock => write!(f, "acquire-lock"),
            Self::ReleaseLock => write!(f, "release-lock"),
            Self::StoreData => write!(f, "store-data"),
            Self::WorkflowStep => write!(f, "workflow-step"),
            Self::MarkEventHandled => write!(f, "mark-event-handled"),
            Self::ValidateApproval => write!(f, "validate-approval"),
            Self::Other => write!(f, "other"),
        }
    }
}

// ============================================================================
// Output Formatting
// ============================================================================

fn redact_json_value(value: &mut serde_json::Value, redactor: &Redactor) {
    match value {
        serde_json::Value::String(text) => {
            *text = redactor.redact(text);
        }
        serde_json::Value::Array(items) => {
            for item in items {
                redact_json_value(item, redactor);
            }
        }
        serde_json::Value::Object(map) => {
            for value in map.values_mut() {
                redact_json_value(value, redactor);
            }
        }
        serde_json::Value::Null | serde_json::Value::Bool(_) | serde_json::Value::Number(_) => {}
    }
}

/// Format a dry-run report as JSON
pub fn format_json(report: &DryRunReport) -> Result<String, serde_json::Error> {
    serde_json::to_string_pretty(&report.redacted())
}

/// Format a dry-run report for human-readable TTY output
#[must_use]
pub fn format_human(report: &DryRunReport) -> String {
    use std::fmt::Write;

    let report = report.redacted();
    let mut output = String::new();

    // Header
    output.push_str("DRY RUN - No changes will be made\n");
    output.push_str(&"─".repeat(40));
    output.push('\n');

    // Command
    if !report.command.is_empty() {
        let _ = writeln!(output, "\nCommand: {}", report.command);
    }

    // Target Resolution
    if let Some(target) = &report.target_resolution {
        output.push_str("\nTarget Resolution:\n");
        let _ = write!(output, "  Pane: {}", target.pane_id);
        if let Some(title) = &target.title {
            let _ = write!(output, " ({title})");
        }
        output.push('\n');
        let _ = writeln!(output, "  Domain: {}", target.domain);
        if let Some(cwd) = &target.cwd {
            let _ = writeln!(output, "  CWD: {cwd}");
        }
        if let Some(agent) = &target.agent_type {
            let _ = writeln!(output, "  Agent: {agent}");
        }
    }

    // Policy Evaluation
    if let Some(policy) = &report.policy_evaluation {
        output.push_str("\nPolicy Evaluation:\n");
        for check in &policy.checks {
            let symbol = if check.passed { "✓" } else { "✗" };
            let _ = writeln!(output, "  {symbol} {}: {}", check.name, check.message);
            if let Some(details) = &check.details {
                let _ = writeln!(output, "    {details}");
            }
        }
    }

    // Expected Actions
    if !report.expected_actions.is_empty() {
        output.push_str("\nExpected Actions:\n");
        for action in &report.expected_actions {
            let _ = writeln!(
                output,
                "  {}. [{}] {}",
                action.step, action.action_type, action.description
            );
        }
    }

    // Warnings
    if !report.warnings.is_empty() {
        output.push_str("\nWarnings:\n");
        for warning in &report.warnings {
            let _ = writeln!(output, "  ⚠ {warning}");
        }
    }

    // Footer with execution hint
    output.push('\n');
    output.push_str(&"─".repeat(40));
    output.push_str("\nTo execute for real, remove --dry-run flag\n");

    output
}

// ============================================================================
// Builder Helpers
// ============================================================================

/// Helper to build a policy evaluation for a send command
#[must_use]
pub fn build_send_policy_evaluation(
    rate_limit_status: (u32, u32), // (current, limit)
    is_prompt_active: bool,
    require_prompt_active: bool,
    has_recent_gaps: bool,
) -> PolicyEvaluation {
    let mut eval = PolicyEvaluation::new();

    // Rate limit check
    let (current, limit) = rate_limit_status;
    if limit == 0 {
        eval.add_check(PolicyCheck::passed(
            "rate_limit",
            "Rate limit disabled".to_string(),
        ));
    } else if current < limit {
        eval.add_check(PolicyCheck::passed(
            "rate_limit",
            format!("{current}/{limit} sends in last minute (within budget)"),
        ));
    } else {
        eval.add_check(PolicyCheck::failed(
            "rate_limit",
            format!("Rate limit exceeded: {current}/{limit}"),
        ));
    }

    // Prompt state check
    if require_prompt_active {
        if is_prompt_active {
            eval.add_check(PolicyCheck::passed(
                "pane_state",
                "PromptActive (safe to send)",
            ));
        } else {
            eval.add_check(PolicyCheck::failed(
                "pane_state",
                "Prompt not active - command may be running",
            ));
        }
    } else {
        eval.add_check(PolicyCheck::passed(
            "pane_state",
            "Prompt check not required",
        ));
    }

    // Continuity check
    if has_recent_gaps {
        eval.add_check(
            PolicyCheck::passed("continuity", "Recent gap detected")
                .with_details("Output continuity may be affected; consider waiting for stability"),
        );
    } else {
        eval.add_check(PolicyCheck::passed("continuity", "No recent gaps (OK)"));
    }

    eval
}

/// Helper to create a send action
#[must_use]
pub fn create_send_action(step: u32, pane_id: u64, text_len: usize) -> PlannedAction {
    PlannedAction::new(
        step,
        ActionType::SendText,
        format!("Inject {text_len} characters via wezterm cli send-text --pane-id {pane_id}"),
    )
}

/// Helper to create a wait-for action
#[must_use]
pub fn create_wait_for_action(
    step: u32,
    condition: impl Into<String>,
    timeout_ms: u64,
) -> PlannedAction {
    PlannedAction::new(
        step,
        ActionType::WaitFor,
        format!("Wait for: {} (timeout: {}ms)", condition.into(), timeout_ms),
    )
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn dry_run_context_creation() {
        let enabled = DryRunContext::enabled();
        assert!(enabled.is_dry_run());

        let disabled = DryRunContext::disabled();
        assert!(!disabled.is_dry_run());

        let from_flag_true = DryRunContext::from_flag(true);
        assert!(from_flag_true.is_dry_run());

        let from_flag_false = DryRunContext::from_flag(false);
        assert!(!from_flag_false.is_dry_run());
    }

    #[test]
    fn command_context_builds_dry_run_context() {
        let ctx = CommandContext::new("wa send --pane 1 \"hi\" --dry-run", true);
        let dry_ctx = ctx.dry_run_context();
        assert!(dry_ctx.is_dry_run());
        assert_eq!(dry_ctx.report.command, "wa send --pane 1 \"hi\" --dry-run");
    }

    #[test]
    fn dry_run_context_building() {
        let mut ctx = DryRunContext::enabled();
        ctx.set_command("wa send --pane 1 \"hello\"");
        ctx.set_target(TargetResolution::new(1, "local").with_title("test"));
        ctx.add_warning("Test warning");
        ctx.add_action(PlannedAction::new(1, ActionType::SendText, "Send hello"));

        let report = ctx.take_report();
        assert_eq!(report.command, "wa send --pane 1 \"hello\"");
        assert!(report.target_resolution.is_some());
        assert_eq!(report.warnings.len(), 1);
        assert_eq!(report.expected_actions.len(), 1);
    }

    #[test]
    fn dry_run_report_serialization() {
        let mut report = DryRunReport::with_command("test command");
        report.target_resolution = Some(TargetResolution::new(42, "local"));
        report.warnings.push("warning 1".to_string());

        let json = format_json(&report).expect("serialization should succeed");
        assert!(json.contains("test command"));
        assert!(json.contains("42"));
        assert!(json.contains("warning 1"));
    }

    #[test]
    fn format_json_redacts_secrets() {
        let secret = "sk-abc123456789012345678901234567890123456789012345678901";
        let mut report = DryRunReport::with_command(format!("wa send {secret}"));
        report
            .warnings
            .push(format!("token: {secret} should be hidden"));

        let json = format_json(&report).expect("serialization should succeed");
        assert!(json.contains("[REDACTED]"));
        assert!(!json.contains("sk-abc"));
    }

    #[test]
    fn policy_evaluation_all_passed() {
        let mut eval = PolicyEvaluation::new();
        eval.add_check(PolicyCheck::passed("check1", "ok"));
        eval.add_check(PolicyCheck::passed("check2", "ok"));
        assert!(eval.all_passed());

        eval.add_check(PolicyCheck::failed("check3", "failed"));
        assert!(!eval.all_passed());
    }

    #[test]
    fn policy_check_from_policy_decision() {
        use crate::policy::PolicyDecision;

        let allowed = PolicyDecision::allow();
        let check: PolicyCheck = (&allowed).into();
        assert!(check.passed);

        let denied = PolicyDecision::deny("test reason");
        let check: PolicyCheck = (&denied).into();
        assert!(!check.passed);
        assert_eq!(check.message, "test reason");

        let approval = PolicyDecision::require_approval("approval needed");
        let check: PolicyCheck = (&approval).into();
        assert!(!check.passed);
        assert!(check.message.contains("approval needed"));
    }

    #[test]
    fn human_format_includes_all_sections() {
        let mut report = DryRunReport::with_command("test");
        report.target_resolution = Some(TargetResolution::new(1, "local"));

        let mut eval = PolicyEvaluation::new();
        eval.add_check(PolicyCheck::passed("test", "passed"));
        report.policy_evaluation = Some(eval);

        report
            .expected_actions
            .push(PlannedAction::new(1, ActionType::SendText, "action"));
        report.warnings.push("warning".to_string());

        let output = format_human(&report);
        assert!(output.contains("DRY RUN"));
        assert!(output.contains("Target Resolution"));
        assert!(output.contains("Policy Evaluation"));
        assert!(output.contains("Expected Actions"));
        assert!(output.contains("Warnings"));
    }

    #[test]
    fn build_send_policy_evaluation_all_ok() {
        let eval = build_send_policy_evaluation((5, 30), true, true, false);
        assert!(eval.all_passed());
        assert_eq!(eval.checks.len(), 3);
    }

    #[test]
    fn build_send_policy_evaluation_rate_limited() {
        let eval = build_send_policy_evaluation((30, 30), true, true, false);
        assert!(!eval.all_passed());
        assert_eq!(eval.failed_checks().len(), 1);
    }

    #[test]
    fn create_send_action_format() {
        let action = create_send_action(1, 42, 100);
        assert_eq!(action.step, 1);
        assert_eq!(action.action_type, ActionType::SendText);
        assert!(action.description.contains("100 characters"));
        assert!(action.description.contains("42"));
    }

    #[test]
    fn action_type_display() {
        assert_eq!(format!("{}", ActionType::SendText), "send-text");
        assert_eq!(format!("{}", ActionType::WaitFor), "wait-for");
        assert_eq!(format!("{}", ActionType::AcquireLock), "acquire-lock");
    }

    #[test]
    fn target_resolution_builder() {
        let target = TargetResolution::new(1, "local")
            .with_title("test title")
            .with_cwd("/home/user")
            .with_is_active(true)
            .with_agent_type("claude_code");

        assert_eq!(target.pane_id, 1);
        assert_eq!(target.domain, "local");
        assert_eq!(target.title, Some("test title".to_string()));
        assert_eq!(target.cwd, Some("/home/user".to_string()));
        assert_eq!(target.is_active, Some(true));
        assert_eq!(target.agent_type, Some("claude_code".to_string()));
    }
}
